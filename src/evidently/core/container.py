import abc
import itertools
from typing import TYPE_CHECKING
from typing import ClassVar
from typing import Generator
from typing import List
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Union

from evidently.core.metric_types import Metric
from evidently.core.metric_types import MetricId
from evidently.core.metric_types import convert_tests
from evidently.legacy.model.widget import BaseWidgetInfo
from evidently.pydantic_utils import AutoAliasMixin
from evidently.pydantic_utils import EvidentlyBaseModel

if TYPE_CHECKING:
    from evidently.core.report import Context

MetricOrContainer = Union[Metric, "MetricContainer"]


class MetricContainer(AutoAliasMixin, EvidentlyBaseModel, abc.ABC):
    """Base class for containers that generate multiple metrics.

    Metric containers are used to programmatically create multiple related metrics,
    such as generating the same metric for multiple columns or creating metric combinations.
    Examples include `ColumnMetricGenerator` and preset classes like `DataDriftPreset`.
    """

    __alias_type__: ClassVar[str] = "metric_container"

    class Config:
        is_base_type = True

    include_tests: bool = True
    """Whether to include default tests for generated metrics."""

    def __init__(self, include_tests: bool = True, **data):
        """Initialize a metric container.

        Args:
        * `include_tests`: If `True`, generated metrics will include default tests.
        """
        self.include_tests = include_tests
        super().__init__(**data)

    @abc.abstractmethod
    def generate_metrics(self, context: "Context") -> Sequence[MetricOrContainer]:
        """Generate metrics based on the container configuration.

        Args:
        * `context`: `Context` containing datasets and configuration.

        Returns:
        * Sequence of `Metric` or `MetricContainer` objects to compute.
        """
        raise NotImplementedError()

    def metrics(self, context: "Context") -> List[MetricOrContainer]:
        """Get all metrics generated by this container.

        Results are cached in the context to avoid regenerating on subsequent calls.

        Args:
        * `context`: `Context` containing datasets and configuration.

        Returns:
        * List of `Metric` or `MetricContainer` objects.
        """
        metric_container_fp = self.get_fingerprint()
        metrics = context.metrics_container(metric_container_fp)
        if metrics is None:
            metrics = list(self.generate_metrics(context))
            context.set_metric_container_data(metric_container_fp, metrics)
        return metrics

    def render(
        self,
        context: "Context",
        child_widgets: Optional[List[Tuple[Optional[MetricId], List[BaseWidgetInfo]]]] = None,
    ) -> List[BaseWidgetInfo]:
        """Render visualization widgets for this container.

        Combines widgets from all child metrics/containers.

        Args:
        * `context`: `Context` containing datasets and configuration.
        * `child_widgets`: Optional list of (metric_id, widgets) tuples from child metrics.

        Returns:
        * List of `BaseWidgetInfo` objects for visualization.
        """
        return list(itertools.chain(*[widget[1] for widget in (child_widgets or [])]))

    def list_metrics(self, context: "Context") -> Generator[Metric, None, None]:
        """Iterate over all leaf metrics in this container.

        Recursively yields all `Metric` objects, flattening nested containers.

        Args:
        * `context`: `Context` containing datasets and configuration.

        Yields:
        * `Metric` objects from this container and nested containers.

        Raises:
        * `ValueError`: If metrics haven't been generated yet.
        """
        metrics = context.metrics_container(self.get_fingerprint())
        if metrics is None:
            raise ValueError("Metrics weren't composed in container")
        for item in metrics:
            if isinstance(item, Metric):
                yield item
            elif isinstance(item, MetricContainer):
                yield from item.list_metrics(context)
            else:
                raise ValueError(f"invalid metric type {type(item)}")

    def _get_tests(self, tests):
        """Get tests list, handling None and include_tests flag.

        Args:
        * `tests`: Optional list of tests.

        Returns:
        * Converted tests list, or None if default tests should be used, or empty list if tests disabled.
        """
        if tests is not None:
            return convert_tests(tests)
        if self.include_tests:
            return None
        return []


MetricOrContainer = Union[Metric, MetricContainer]


class ColumnMetricContainer(MetricContainer, abc.ABC):
    """Base class for metric containers that operate on a specific column.

    Simplifies container implementation for containers that generate metrics
    for a single column. Subclasses only need to implement `generate_metrics()`.
    """

    column: str
    """Name of the column to generate metrics for."""

    def __init__(self, column: str, include_tests: bool = True):
        """Initialize a column metric container.

        Args:
        * `column`: Name of the column to generate metrics for.
        * `include_tests`: If `True`, generated metrics will include default tests.
        """
        self.column = column
        super().__init__(include_tests=include_tests)
